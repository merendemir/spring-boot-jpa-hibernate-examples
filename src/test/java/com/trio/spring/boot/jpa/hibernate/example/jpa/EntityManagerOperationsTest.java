package com.trio.spring.boot.jpa.hibernate.example.jpa;

import com.trio.spring.boot.jpa.hibernate.example.repository.domain.Users;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.Root;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.test.context.jdbc.Sql;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

// @Sql annotation to execute SQL scripts before and after the test class.
// We are pointing to SQL files in src/test/resources.
@Sql(
        scripts = {"classpath:sql/init_users.sql"},
        executionPhase = Sql.ExecutionPhase.BEFORE_TEST_CLASS
)
@Sql(
        scripts = "classpath:sql/cleanup_users.sql",
        executionPhase = Sql.ExecutionPhase.AFTER_TEST_CLASS
)
@DataJpaTest // Loads JPA components and configures a test database
@Slf4j
@DisplayName("EntityManager Basic Operations Tests")
public class EntityManagerOperationsTest {

    // This class will contain tests for basic EntityManager operations
    // such as find, persist, merge, remove, and using Criteria API for queries.

    private final Long USER_ID_FOR_RETRIEVE = 1000L;
    private final Long USER_ID_FOR_DELETE = 1001L;
    private final Long USER_ID_FOR_UPDATE = 1002L;
    private final String RETRIEVE_USER_FIRST_NAME = "Alice";
    private final String RETRIEVE_USER_LAST_NAME = "Smith";

    @PersistenceContext // Injects the EntityManager
    private EntityManager entityManager;

    @Test
    @DisplayName("Should find an existing user using EntityManager.find()")
    void shouldFindExistingUser() {
        // find(): Retrieves an entity by its primary key directly from the Persistence Context or the database.
        log.info("::: shouldFindExistingUser ::: You can see the SELECT query generated by Hibernate right after this log");
        Users foundUsers = entityManager.find(Users.class, USER_ID_FOR_RETRIEVE);

        assertNotNull(foundUsers);
        assertEquals(USER_ID_FOR_RETRIEVE, foundUsers.getId(), "User ID should match");
        assertEquals(RETRIEVE_USER_FIRST_NAME, foundUsers.getFirstName(), "User first name should match");
        assertEquals(RETRIEVE_USER_LAST_NAME, foundUsers.getLastName(), "User last name should match");
    }

    @Test
    @DisplayName("Should persist a new student using EntityManager.persist()")
    void shouldPersistNewUsers() {
        Users users = new Users();
        users.setFirstName("Bob");
        users.setLastName("Johnson");

        // persist(): Adds a new entity to the persistence context and assigns it an ID.
        // At this point, no INSERT query is sent to the database; it's just managed within the context.
        log.info("::: shouldPersistNewUsers ::: You can see the INSERT query generated by Hibernate right after this log");
        entityManager.persist(users);

        assertNotNull(users.getId()); // ID should be assigned
        assertThat(users.getId()).isGreaterThan(0);

        // find(): Retrieves the entity from the database by its ID.
        Users foundUsers = entityManager.find(Users.class, users.getId());
        assertThat(foundUsers).isNotNull();
        assertThat(foundUsers.getFirstName()).isEqualTo("Bob");
        assertThat(foundUsers.getLastName()).isEqualTo("Johnson");
    }

    @Test
    @DisplayName("Should update an existing user using EntityManager.merge()")
    void shouldUpdateExistingUser() {
        // Create a detached user to simulate an update scenario
        Users userToUpdate = entityManager.find(Users.class, USER_ID_FOR_UPDATE);
        userToUpdate.setFirstName("Alice Updated");
        userToUpdate.setLastName("Smith New");

        log.info("::: shouldUpdateExistingUser ::: Merging user with updated details. An UPDATE query will be generated.");
        // merge(): Reattaches a detached entity to the persistence context or makes a new detached entity persistent.
        // The return value is the managed entity.
        Users mergedUsers = entityManager.merge(userToUpdate);

        // Verify the managed entity
        assertThat(mergedUsers).isNotNull();
        assertEquals("Alice Updated", mergedUsers.getFirstName());
        assertEquals("Smith New", mergedUsers.getLastName());

        // Fetch from DB to confirm the update
        Users verifiedUsers = entityManager.find(Users.class, USER_ID_FOR_UPDATE);
        assertNotNull(verifiedUsers);
        assertEquals("Alice Updated", verifiedUsers.getFirstName());
        assertEquals("Smith New", verifiedUsers.getLastName());
    }

    @Test
    @DisplayName("Should remove an existing user using EntityManager.remove()")
    void shouldRemoveExistingUser() {
        // find(): Retrieves the entity to be removed
        Users userToRemove = entityManager.find(Users.class, USER_ID_FOR_DELETE);
        assertNotNull(userToRemove, "User to remove should not be null");
        log.info("::: shouldRemoveExistingUser ::: Removing user with ID: {}", USER_ID_FOR_DELETE);
        // remove(): Marks the entity for removal from the database.
        entityManager.remove(userToRemove);
        // Verify the user is removed
        Users removedUser = entityManager.find(Users.class, USER_ID_FOR_DELETE);
        assertThat(removedUser).isNull(); // The user should no longer exist
    }

    @Test
    @DisplayName("Should find users by first name using EntityManager and Criteria API")
    void shouldFindUsersByFirstNameUsingEntityManager() {
        // Create a CriteriaBuilder and CriteriaQuery
        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder(); // CriteriaBuilder is used to construct criteria queries, compound selections, expressions, predicates, etc.
        CriteriaQuery<Users> query = criteriaBuilder.createQuery(Users.class); // CriteriaQuery is used to define the query structure and specify the result type.

        // Specify the root entity
        Root<Users> root = query.from(Users.class);

        // Add a "LIKE" condition to filter by first name
        query.select(root)
                .where(criteriaBuilder.like(root.get("firstName"), "%Ali%"));

        log.info("::: shouldFindUsersByFirstNameUsingEntityManager ::: Creating a query to fetch users with first name like '%Ali%'");

        // Execute the query and get the result list
        List<Users> resultList = entityManager.createQuery(query).getResultList();

        // Verify the result
        assertThat(resultList).isNotEmpty();
        log.info("::: shouldFindUsersByFirstNameUsingEntityManager ::: Found {} users in the database with first name like '%Ali%'", resultList.size());
    }

}